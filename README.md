2024.6.10 update

没想到都2024年了还会有人翻到这个repo来问我问题哈哈哈，我这里再做点详细的说明，也算是给后边的学弟们做点好事吧。

首先是我发现自己之前忘记把原理图和PCB放到这个仓库里了，现在已经加到里面了，当时是用的立创EDA花的，原理图和PCB不是很复杂，因为当时是用的**最小系统板 + 扩展板**的形式，也就是说这个原理图和PCB只是扩展板的，上面主要是引除了一些GPIO，然后硬件上使用了xh2.54等接口，主要是防止杜邦线掉落。

> 怎么说呢，虽然这个项目当时拿了省一，我也因此才有机会保研，但是现在看来不管是硬件还是软件写的都很糟糕，规范性比较差，不太具有学习的价值了。但是细心看的话还是可能有作用的吧...



# 旅游机器人赛后总结

### 1.硬件介绍

1.主控：STM32F103ZET6

2.用到的传感器：

    a.8路灰度传感器

    b.光电传感器

    c.MPU6050

    d.色标传感器

3.小车结构:

    a.结构上采用合页式结构，如果轮子太小而车整体高度较低，可能会导致过梯形山不好过，可以将合页与舵机相连，在过这些不好过的景点是用舵机将车头抬起来。

    b.在车头的合页处可以加上一个挡板，当车头抬起的时候该挡板可以挡住光电传感器，以此来判断车是否上坡/上台/过梯形山。(感觉比用6050读roll角来判断更稳一些)

### 2.一些细节问题

1.平台处由于黄线的存在，直接靠灰度寻迹可以会导致车寻到黄线而歪掉，因此下台时可以先用定时器让小车开环跑一小段距离，灰度大致到了白线上时再开始寻迹。可以将上平台和下平台单独写一个函数，这样提高代码的复用性。

```c
/******************************************************
*函数名称：platform_new
*函数功能：先快速走到上坡处,然后慢速上平台并自转一圈
*说明    ：
******************************************************/
void platform_new(void)//上平台并自转一圈
{
    TIM1_OFF();
    /* 平地 */
    while(1)
    {
        go_forward(Road_Speed_H,Straight_Quick);//在平地快速寻迹直到走到平台上
        Read_Digital_Data();

        if(G_L==0)
            break;//到上坡了
    }

    /* 上坡 */
    TIM1_ON();
    while(1)
    {
        _MPU_READ;
        go_forward(Up_Platform,Straight_Slow);//在平地慢速寻迹直到走到平台上
        if(sum1<=4 && _second > 0.4)    //已经走到了平台上
        {
            TIM1_OFF();
            break;
        }
    }
    dash_op();
    stop(Base_delay);

    _MPU_READ;
    _MPU_READ;
    turn_right(550,165);//在平台上自转一圈170
}
```

```c
/******************************************************
*函数名称：down_platform
*函数功能：慢速下台直到完全走到平地上
*说明    ：
******************************************************/
void down_platform(void)
{
    dash_dp();
    while(1)
    {
        go_forward(Down_Platform,Straight_Quick);
        if(G_L == 0)
            break;
    }

    while(1)
    {
        go_forward(Down_Platform,Straight_Quick);
        if(G_L == 1)
            break;
    }
}
```

2.在平地上转弯时，完全可以通过灰度来转而不是用6050的YAW角，如果用YAW角，必须事先确定所要转的角度，可能需要花费更多的调试时间。建议用灰度结合定时器来转，设定一个最小时间，当时间大于此阈值且灰度中间的2个检测到白线时，转角结束。

```c
/* 左/右转直到车中线到白线 */
void turn_until_line(int L_speed,int R_speed,float time)//用于分叉时转到另一根线上
{
    TIM1_ON();
    while(1)
    {
        Read_Digital_Data();
        motor(L_speed,R_speed);
        if( (E4==0||E5==0) && (_second>=time) )
        {
            stop(Base_delay);
            break;
        }
    }
    TIM1_OFF();
}
```

3.传感器读取数据时，尽量加一些滤波，在某些景点可能一次数据读的有问题就直接结束了。。。并且要选择合适的采样周期，并注意算法的时间复杂度，有时候可能车跑的太快了，你的传感器采样次数过多再加上滤波可能来不及。

4.在做旅游机器人的时候，第一个该调试的就是它的寻迹功能，而寻迹一般都是通过灰度来寻的。对于寻迹，可以通过灰度在不同位置时，电机差速转动来寻，也可通过PID来寻。由于所使用的灰度一般都是数字量灰度，所以除了PID的KP、KI、KD 3个参数，在调试寻迹的时候，我们还需要根据灰度的位置自定其返回的ERROR值，以此来计算输出。在走不同的地形时(直线或S弯)可以适当的改变一下PID的参数。为了防止车头在寻迹时来回抖动，积分项建议在车头摆正时清0，或者直接就把KI设为0。想要寻迹效果更好的话，除了通过灰度对小车的位置闭环，还可以使用编码器电机对速度也闭环并作为位置环的内环。
